<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="LumberChunker: Efficient Text Chunking with Late Merging">
  <meta name="keywords" content="LumberChunker, RAG, Text Chunking, LLM">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>LumberChunker: Long-Form Narrative Document Segmentation</title>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,500,700">

  <!-- Bulma CSS -->
  <link rel="stylesheet" href="../disco/static/css/bulma.min.css">
  <link rel="stylesheet" href="../disco/static/css/bulma-carousel.min.css">
  <link rel="stylesheet" href="../disco/static/css/bulma-slider.min.css">
  
  <!-- FontAwesome & Academicons -->
  <link rel="stylesheet" href="../disco/static/css/fontawesome.all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
  
  <!-- Your Custom CSS -->
  <link rel="stylesheet" href="../disco/static/css/index.css">
  
  <!-- Favicon -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>LC</text></svg>">

  <!-- jQuery -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  
  <!-- Bootstrap CSS AFTER Bulma so that the navbar styles take precedence -->
  <link rel="stylesheet" 
        href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/css/bootstrap.min.css"
        integrity="sha512-P5MgMn1jBN01asBgU0z60Qk4QxiXo86+wlFahKrsQf37c9cro517WzVSPPV1tDKzhku2iJ2FVgL67wG03SGnNA=="
        crossorigin="anonymous" />

  <!-- Bootstrap JS (with Popper.js) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
          integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
          crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/js/bootstrap.min.js"
          integrity="sha512-XKa9Hemdy1Ui3KSGJdgMyYlUg1gM+QhL6cnlyTe2qzMCYm4nAZ1PsVerQzTTXzonUR+dmswHqgJPuwCq1MaAg=="
          crossorigin="anonymous"></script>
  
  <!-- FontAwesome, Bulma Carousel, etc. -->
  <script defer src="../disco/static/js/fontawesome.all.min.js"></script>
  <script src="../disco/static/js/bulma-carousel.min.js"></script>
  <script src="../disco/static/js/bulma-slider.min.js"></script>
  <script src="../disco/static/js/index.js"></script>

  <!-- d3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    /* Slightly increase the base font size */
    body {
        font-size: 20px;
        color: #424242 !important;
    }

    p {
      margin-bottom: 12px !important;
    }

    /* For mobile devices: change text alignment to left */
    @media screen and (max-width: 1000px) {
      .content.has-text-justified {
        text-align: left !important;
      }
    }

    .title.is-3{
      color: #3e3e3e !important;
      font-weight: bold;
      margin-top: -2rem;
    }

    .title.is-4 {
      color: #686868 !important;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .image-wrapper{
      justify-content: center;
      align-items: center;
      margin-bottom: 20px;
    }

    @media screen and (max-width: 1000px) {
      .image-wrapper {
        width: 100% !important;
      }
      .image-wrapper img {
        width: 90% !important;
      }
    }

    /* Quiz/Interactive Section Styling */
    .quiz-section {
      background-color: #f8f9fa;
      padding: 2rem;
      border-radius: 10px;
      margin: 2rem 0;
    }

    .quiz-iframe-container {
      width: 100%;
      height: 800px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      background: white;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .quiz-iframe-container iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Custom Tab Styling */
    .custom-tabs {
      margin-bottom: 1.5rem !important;
      border-bottom: 1px solid #e0e0e0 !important;
      font-family: 'Roboto', sans-serif !important;
    }

    .custom-tabs ul {
      display: flex !important;
      justify-content: center !important;
      list-style: none !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .custom-tabs ul li {
      padding: 0.75rem 1.5rem !important;
      margin: 0 0.5rem !important;
      cursor: pointer !important;
      position: relative !important;
      font-size: 1.1rem !important;
      color: #9e9e9e !important;
      transition: color 0.25s ease !important;
    }

    .custom-tabs ul li:not(.is-active):hover {
      color: rgb(47, 47, 47) !important;
    }

    .custom-tabs ul li.is-active {
      color: #464646 !important;
      font-weight: 600 !important;
    }

    .custom-tabs ul li.is-active::after {
      content: '' !important;
      position: absolute !important;
      left: 0 !important;
      right: 0 !important;
      bottom: -1px !important;
      height: 3px !important;
      background-color: #464646 !important;
      border-radius: 2px !important;
    }

    /* Card-like Table Container */
    .table-card {
      margin: 0 auto !important;
      max-width: 100% !important;
    }

    table.table {
      width: 100% !important;
      font-family: 'Roboto', sans-serif !important;
      border-collapse: collapse !important;
    }

    table.table caption {
      caption-side: top !important;
      text-align: center !important;
      font-weight: 600 !important;
      margin-bottom: 0.75rem !important;
      font-size: 1.15rem !important;
      color: #464646 !important;
    }

    table.table th,
    table.table td {
      padding: 0.75rem !important;
      border: 1px solid #f0f0f0 !important;
      text-align: center !important;
      font-size: clamp(0.65rem, 2vw, 1rem) !important;
      color: #464646 !important;
    }

    table.table th {
      background: #fafafa !important;
      vertical-align: middle !important;
    }

    .table-card table.table th:first-child,
    .table-card table.table td:first-child {
      white-space: nowrap !important;
      text-align: left !important;
    }

    /* Algorithm box styling */
    .algorithm-box {
      background-color: #f5f5f5;
      border-left: 4px solid #626161;
      padding: 1.5rem;
      margin: 1.5rem 0;
      border-radius: 4px;
    }

    .algorithm-box code {
      background-color: #fff;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-size: 0.9em;
    }

  </style>
</head>
<body>

  <!-- Begin Bulma-Based Page Content -->

  <section class="hero">
    <div class="hero-body">
      <div class="container is-max-desktop">
        <div class="columns is-centered">
          <div class="column has-text-centered">
            <h1 class="title is-1 publication-title">
              LumberChunker: Long-Form Narrative Document Segmentation
            </h1>
            <p style="font-size: 1.1rem; color: #666; margin-bottom: 1rem;">
              Blog created by Raymond Jiang<sup>3</sup>
            </p>
            <div class="is-size-5 publication-authors">
              <span class="author-block">
                <a href="#">André V. Duarte</a><sup>1</sup>,
              </span>
              <span class="author-block">
                <a href="#">João Marques</a><sup>1</sup>,
              </span>
              <span class="author-block">
                <a href="#">Miguel Graça</a><sup>1</sup>
              </span>
              <span class="author-block">
                <a href="#">Miguel Freire</a><sup>2</sup>
              </span>
              <span class="author-block">
                <a href="#">Lei Li</a><sup>3</sup>
              </span>
              <span class="author-block">
                <a href="#">Arlindo Oliveira</a><sup>1</sup>
              </span>
            </div>
            <div class="is-size-5 publication-authors">
              <span class="author-block"><sup>1</sup>INESC-ID / Instituto Superior Técnico, <sup>2</sup>NeuralShift AI, <sup>3</sup>Carnegie Mellon University</span>
            </div>
            <div class="column has-text-centered">
              <div class="publication-links">
                <!-- PDF Link -->
                <span class="link-block">
                  <a href="https://arxiv.org/pdf/2406.17526" target="_blank" class="external-link button is-normal is-rounded is-dark">
                    <span class="icon"><i class="fas fa-file-pdf"></i></span>
                    <span>Paper</span>
                  </a>
                </span>
                <!-- Code Link -->
                <span class="link-block">
                  <a href="https://github.com/joaodsmarques/LumberChunker" target="_blank" class="external-link button is-normal is-rounded is-dark">
                    <span class="icon"><i class="fab fa-github"></i></span>
                    <span>Code</span>
                  </a>
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>


  <!-- Teaser Section -->
  <section class="section">
    <div class="container is-max-desktop">
      <div class="columns is-centered">
        <div class="column is-four-fifths has-text-centered">
          <div class="image-wrapper" id="pipeline-image-wrapper" style="display: flex; justify-content: center; align-items: center;">
          </div>
          <p style="margin-top: 1rem;">
            We present LumberChunker, a method for semantically segmenting long-form narrative documents that achieves state-of-the-art retrieval performance while requiring significantly fewer embedding computations than existing approaches.
          </p>
        </div>
      </div>
    </div>
  </section>

  
<!-- Introduction & Key Idea -->
<section class="section">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-left">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Introduction</h2>
        <div class="content has-text-justified">
          <p>
            Long-form narratives (novels, memoirs, transcripts) don’t break cleanly at fixed token counts. If we split them poorly, Retrieval-Augmented Generation (RAG) pipelines surface the wrong passages and LLMs start guessing. Structure-only chunkers (fixed tokens, paragraphs) are fast but blind to scene and topic flow; purely similarity-driven heuristics can fragment dialogue, miss coreference, and drift as context grows.
          </p>
          <p>
            <span style="font-weight: 600;">So how do we preserve the story’s flow and still keep chunking practical?</span>
          </p>

          <h2 class="title is-4">The Key Idea</h2>
          <p>
            Treat segmentation as <em>boundary finding</em>. LumberChunker reads a rolling window of consecutive paragraphs (up to a token count <code>θ</code>) and asks an LLM to return the <strong>earliest paragraph where the content clearly shifts</strong> from what came before. That paragraph marks a boundary; the next chunk starts there. Repeat until the document ends.
          </p>
          <p>
            This simple prompt design yields reliable, human-like cuts because:
          </p>
          <ul>
            <li>
              <strong>Low false positives when no shift exists.</strong> Without a genuine topic/scene turn, the model rarely flags a boundary, so chunks don’t fracture mid-thought.
            </li>
            <li>
              <strong>High hit-rate when a shift does exist.</strong> When the narrative pivots (new scene, entity, objective), the model consistently identifies the earliest turning point, preserving coherence.
            </li>
          </ul>
          <p>
            In practice, sweeping the window size shows a sweet spot around <strong>θ ≈ 550 tokens</strong>: enough context to recognize transitions, but not so much that the signal gets diluted.
          </p>

          <p>
            Want to test your understanding? Try the interactive quiz below to see if you can identify the optimal way to segment a passage.
          </p>
        </div>
      </div>
    </div>
  </div>
</section>

  <!-- Interactive Quiz Section -->
  <section class="section" id="quiz" style="margin-top: -2rem; margin-bottom: -2.5rem;">
    <div class="container is-max-desktop">
      <div class="quiz-section">
        <div class="quiz-iframe-container">
          <iframe src="quiz.html" title="Text Segmentation Quiz"></iframe>
        </div>
      </div>
    </div>
  </section>


  <!-- Method Section (Updated to LumberChunker style) -->
  <section class="section" id="method">
    <div class="container is-max-desktop">
      <div class="columns is-centered has-text-left">
        <div class="column is-four-fifths">
          <h2 class="title is-3">The LumberChunker Method</h2>
          <div class="content has-text-justified">

            <p>
              LumberChunker treats document segmentation as a <em>boundary-finding</em> problem. Instead of cutting by fixed tokens or paragraphs, we ask an LLM to read a rolling window of consecutive paragraphs and return the <strong>first paragraph where the content clearly shifts</strong>. That cut becomes the end of the current chunk and the start of the next, which yields variable-length, semantically coherent segments that track narrative flow.
            </p>

            <h3 class="title is-4" id="step1-extraction">1) Document i Paragraph Extraction</h3>
            <p>
              Cleanly split the book into paragraphs and assign stable IDs (<code>p1, p2, …</code>). This preserves the document’s natural discourse units and gives us safe candidate boundaries.
            </p>

            <div class="algorithm-box">
              <strong>Example:</strong> From a novel, we extract:<br><br>
              <code>p1</code>: "The morning sun filtered through the dusty windows..."<br>
              <code>p2</code>: "She walked slowly to the door, hesitating..."<br>
              <code>p3</code>: "Meanwhile, across town, Detective Morrison reviewed the case files..."<br>
              <code>p4</code>: "The previous night's events had left him puzzled..."<br><br>
              Each paragraph gets a unique ID for tracking boundaries.
            </div>

            <h3 class="title is-4" id="step2-grouping">2) IDs Grouping (G<sub>i</sub>) for LLM</h3>
            <p>
              Build a rolling group <code>G<sub>i</sub></code> by appending paragraphs until the group’s length reaches a token budget <code>θ</code>. This provides enough context for the model to judge when a topic/scene actually shifts.
            </p>

            <div class="algorithm-box">
              <strong>Example:</strong> With <code>θ = 550</code> tokens, we build:<br><br>
              <code>G<sub>1</sub></code> = [<code>p1</code>, <code>p2</code>, <code>p3</code>, <code>p4</code>, <code>p5</code>, <code>p6</code>]<br><br>
              This window contains ~550 tokens spanning multiple paragraphs, giving the LLM enough context to detect where the narrative shifts—perhaps from the woman's scene to the detective's investigation.
            </div>

            <h3 class="title is-4" id="step3-query">3) Gemini Query</h3>
            <p>
              Prompt the model with the paragraphs in <code>G<sub>i</sub></code> and ask it to return the <em>first</em> paragraph (not the very first in the group) where content clearly changes relative to what came before. Use that returned ID as the chunk boundary; start the next group at that paragraph and repeat to the end of the book.
            </p>

            <div class="algorithm-box">
              <strong>Example:</strong> Given <code>G<sub>1</sub></code> = [<code>p1</code>, <code>p2</code>, <code>p3</code>, <code>p4</code>, <code>p5</code>, <code>p6</code>], the LLM responds:<br><br>
              <em>"The content shifts at <code>p3</code>, where we transition from the woman's morning routine to Detective Morrison's investigation."</em><br><br>
              <strong>Step 4: Answer Extraction</strong><br>
              We extract <code>p3</code> as the boundary. This creates:<br>
              • <strong>Chunk 1</strong>: [<code>p1</code>, <code>p2</code>] — Woman's scene<br>
              • <strong>Next group starts at</strong> <code>p3</code> — Detective's investigation
            </div>

            <h3 class="title is-4">Choosing the context size (θ)</h3>
            <p>
              We sweep <code>θ ∈ [450, 1000]</code> tokens and find that <strong>θ ≈ 550</strong> consistently maximizes retrieval quality: large enough for context, small enough to keep the model focused on the current turn in the story.
            </p>

            <!-- <div class="notification is-info is-light">
              <strong>Include Figure 2 here (full-width):</strong> DCG@k across different <code>θ</code>, with <code>θ=550</code> highlighted as the sweet spot.
            </div> -->
            <div style="margin-bottom: 20px;">
              <div style="display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 15px;">
                <label for="theta-slider" style="font-weight: 600; font-size: 16px;">θ (Token Budget):</label>
                <input type="range" id="theta-slider" min="450" max="1000" value="550" step="50" 
                       style="width: 300px; cursor: pointer;">
                <span id="theta-value" style="font-weight: 700; font-size: 18px; color: #ffa726; min-width: 60px;">550</span>
              </div>
            </div>
            <div class="image-wrapper" id="dcg-image-wrapper" style="display: flex; justify-content: center; align-items: center;">
            </div>
            <h3 class="title is-5">Why this works</h3>
            <p>
              Narratives work off of topic turns, scene changes, and discourse shifts, not uniform token distances. By explicitly locating the earliest meaningful change inside a window, LumberChunker produces variable-length chunks that keep entities and events intact, improving retrieval quality downstream.
            </p>

          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Results Section: GutenQA -->
  <section class="section" id="gutenqa">
    <div class="container is-max-desktop">
      <div class="columns is-centered has-text-left">
        <div class="column is-four-fifths">
          <h2 class="title is-3">GutenQA: Movie-style results, but for books</h2>
          <div class="content has-text-justified">

            <p>
              To evaluate chunking where it matters, we introduce <strong>GutenQA</strong>, a benchmark of <strong>100</strong> carefully cleaned public-domain books paired with <strong>3,000</strong> needle-in-a-haystack QA items (short, verifiable answers). This lets us measure <em>passage retrieval</em> precisely and then see how that lift translates into <em>RAG QA</em>.
            </p>

            <h3 class="title is-4">Retrieval: LumberChunker leads ⭐</h3>
            <p>
              Across DCG@k and Recall@k, LumberChunker ranks first. At <code>k=20</code>, it reaches <strong>DCG ≈ 62.1</strong> and <strong>Recall ≈ 77.9%</strong>, outperforming strong baselines like Recursive, Paragraph, Semantic, and Proposition chunking.
            </p>

            <div style="text-align: center; margin-bottom: 1rem;">
              <p style="font-weight: 600; font-size: 1.15rem; color: #464646; margin-bottom: 0.25rem;">Retrieval Performance Comparison</p>
              <p style="font-weight: 200; font-size: 1rem; color: #666;">NarrativeQA</p>
            </div>

            <!-- Custom Tab Interface -->
            <div class="custom-tabs">
              <ul>
                <li class="is-active" data-view="ndcg">DCG @ k</li>
                <li data-view="recall">Recall@k</li>
              </ul>
            </div>

            <!-- Table Card for DCG @ k -->
            <div id="table-container-ndcg" class="table-card">
              <table class="table is-bordered is-hoverable">
                <thead>
                  <tr>
                    <th></th>
                    <th>1</th>
                    <th>2</th>
                    <th>5</th>
                    <th>10</th>
                    <th>20</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th>Semantic Chunking</th>
                    <td>29.50</td>
                    <td>35.31</td>
                    <td>40.67</td>
                    <td>43.14</td>
                    <td>44.74</td>
                  </tr>
                  <tr>
                    <th>Paragraph-Level</th>
                    <td>36.54</td>
                    <td>42.11</td>
                    <td>45.87</td>
                    <td>47.72</td>
                    <td>49.00</td>
                  </tr>
                  <tr>
                    <th>Recursive Chunking</th>
                    <td>39.04</td>
                    <td>45.37</td>
                    <td>50.66</td>
                    <td>53.25</td>
                    <td>54.72</td>
                  </tr>
                  <tr>
                    <th>HyDE<sup>†</sup></th>
                    <td>33.47</td>
                    <td>39.74</td>
                    <td>45.06</td>
                    <td>48.14</td>
                    <td>49.92</td>
                  </tr>
                  <tr>
                    <th>Proposition-Level</th>
                    <td>36.91</td>
                    <td>42.42</td>
                    <td>44.88</td>
                    <td>45.65</td>
                    <td>46.19</td>
                  </tr>
                  <tr style="background-color: #f0f8ff;">
                    <th>LumberChunker</th>
                    <td><strong>48.28</strong></td>
                    <td><strong>54.86</strong></td>
                    <td><strong>59.37</strong></td>
                    <td><strong>60.99</strong></td>
                    <td><strong>62.09</strong></td>
                  </tr>
                </tbody>
              </table>
            </div>

            <!-- Table Card for Recall@k (initially hidden) -->
            <div id="table-container-recall" class="table-card" style="display: none;">
              <table class="table is-bordered is-hoverable">
                <thead>
                  <tr>
                    <th></th>
                    <th>1</th>
                    <th>2</th>
                    <th>5</th>
                    <th>10</th>
                    <th>20</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th>Semantic Chunking</th>
                    <td>29.50</td>
                    <td>38.70</td>
                    <td>50.60</td>
                    <td>58.21</td>
                    <td>64.51</td>
                  </tr>
                  <tr>
                    <th>Paragraph-Level</th>
                    <td>36.54</td>
                    <td>45.37</td>
                    <td>53.67</td>
                    <td>59.34</td>
                    <td>64.34</td>
                  </tr>
                  <tr>
                    <th>Recursive Chunking</th>
                    <td>39.04</td>
                    <td>49.07</td>
                    <td>60.64</td>
                    <td>68.62</td>
                    <td>74.35</td>
                  </tr>
                  <tr>
                    <th>HyDE<sup>†</sup></th>
                    <td>33.47</td>
                    <td>43.41</td>
                    <td>55.11</td>
                    <td>64.61</td>
                    <td>71.61</td>
                  </tr>
                  <tr>
                    <th>Proposition-Level</th>
                    <td>36.91</td>
                    <td>45.64</td>
                    <td>51.04</td>
                    <td>53.41</td>
                    <td>55.54</td>
                  </tr>
                  <tr style="background-color: #f0f8ff;">
                    <th>LumberChunker</th>
                    <td><strong>48.28</strong></td>
                    <td><strong>58.71</strong></td>
                    <td><strong>68.58</strong></td>
                    <td><strong>73.58</strong></td>
                    <td><strong>77.92</strong></td>
                  </tr>
                </tbody>
              </table>
            </div>

            <script>
              document.addEventListener('DOMContentLoaded', function() {
                const tabs = document.querySelectorAll('.custom-tabs ul li');
                const ndcgContainer = document.getElementById('table-container-ndcg');
                const recallContainer = document.getElementById('table-container-recall');
              
                tabs.forEach(tab => {
                  tab.addEventListener('click', () => {
                    // Remove active state from all tabs
                    tabs.forEach(t => t.classList.remove('is-active'));
                    // Activate the clicked tab
                    tab.classList.add('is-active');
              
                    // Toggle the table containers
                    if (tab.getAttribute('data-view') === 'ndcg') {
                      ndcgContainer.style.display = 'block';
                      recallContainer.style.display = 'none';
                    } else {
                      ndcgContainer.style.display = 'none';
                      recallContainer.style.display = 'block';
                    }
                  });
                });
              });
            </script>

            <h3 class="title is-4">Downstream QA: targeted retrieval beats giant context</h3>
            <p>
              Plugging chunks into a standard RAG pipeline (on autobiographies), <strong>RAG-LumberChunker</strong> surpasses <strong>RAG-Recursive</strong> and trails only <strong>RAG-Manual</strong> (hand-segmented ground truth). Notably, an “open-book” non-retrieval setting with huge context windows still underperforms RAG. (<em>targeted passages beat raw context size</em>.)
            </p>

            <!-- <div class="notification is-warning is-light">
              <strong>Include Figure 3 here (full-width):</strong> QA accuracy comparison (RAG-LumberChunker, RAG-Recursive, RAG-Manual, and non-RAG open-book).
            </div> -->

            <div class="image-wrapper" id="qa-image-wrapper" style="display: flex; justify-content: center; align-items: center;">
            </div>

            <h3 class="title is-4">Closer to human boundaries</h3>
            <p>
              Compared against manual chunks, LumberChunker achieves <strong>ROUGE-L ≈ 0.709</strong> vs. <strong>≈ 0.689</strong> for Recursive chunks, which is evidence that its boundaries align with how readers naturally perceive topic shifts.
            </p>

            <!-- Table 2: Similarity to manual segmentation (ROUGE-L) -->
            <div class="table-card" aria-labelledby="table2-caption">
              <table class="table is-bordered is-hoverable">
                <caption id="table2-caption">Table 2: Average ROUGE-L scores of methods compared to Manual Chunks.</caption>
                <thead>
                  <tr>
                    <th style="text-align: left;">Method</th>
                    <th>Average ROUGE-L Score</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td style="text-align: left;">LumberChunker</td>
                    <td>0.709</td>
                  </tr>
                  <tr>
                    <td style="text-align: left;">Recursive Chunks</td>
                    <td>0.689</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <h3 class="title is-4">Granularity that “feels right”</h3>
            <p>
              Average chunk sizes (tokens) on the 100-book corpus: Paragraph ~79, Semantic ~185, Recursive ~399, <strong>LumberChunker ~334</strong>, Proposition ~12. Even with <code>θ=550</code>, the model frequently finds earlier shifts, yielding compact, on-topic chunks and reducing “lost-in-the-middle” effects.
            </p>

            <!-- Table 10: Average tokens and total chunks per method -->

            <!-- Accessible HTML table fallback (renders even if image is missing) -->
            <div class="table-card" aria-labelledby="table10-caption">
              <table class="table is-bordered is-hoverable">
                <caption id="table10-caption">Table 10: The average number of tokens per chunk and the total number of chunks after segmenting each book in the GutenQA.</caption>
                <thead>
                  <tr>
                    <th style="text-align: left;">Method</th>
                    <th>Avg. #Tokens / Chunk</th>
                    <th>Total #Chunks</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td style="text-align: left;">Semantic Chunking</td>
                    <td>185 tokens</td>
                    <td>191059</td>
                  </tr>
                  <tr>
                    <td style="text-align: left;">Paragraph Level</td>
                    <td>79 tokens</td>
                    <td>248307</td>
                  </tr>
                  <tr>
                    <td style="text-align: left;">Recursive Chunking</td>
                    <td>399 tokens</td>
                    <td>31787</td>
                  </tr>
                  <tr>
                    <td style="text-align: left;">Proposition-Level</td>
                    <td>12 tokens</td>
                    <td>914493</td>
                  </tr>
                  <tr style="background-color: #f0f8ff;">
                    <td style="text-align: left;">LumberChunker</td>
                    <td><strong>334 tokens</strong></td>
                    <td><strong>36917</strong></td>
                  </tr>
                </tbody>
              </table>
            </div>

            <h3 class="title is-4">Practicality: predictable time &amp; cost ⚡</h3>
            <p>
              LumberChunker requires LLM calls, but costs scale linearly with book length and are one-time. Examples: <em>A Christmas Carol</em> (~710 paragraphs) ≈ <strong>95 s</strong>, ≈ <strong>$0.03</strong>; <em>The Count of Monte Cristo</em> (~14,339 paragraphs) ≈ <strong>1628 s</strong>, ≈ <strong>$0.40</strong> (pricing at paper time).
            </p>

            <div class="columns">
              <div class="column">
                <!-- Table 11: Runtime (seconds per book) -->

                <!-- Accessible HTML table fallback for Table 11 -->
                <div class="table-card" aria-labelledby="table11-caption">
                  <table class="table is-bordered is-hoverable">
                    <caption id="table11-caption">Table 11: The time required to apply LumberChunker or baselines on each book.</caption>
                    <thead>
                      <tr>
                        <th style="text-align: left;">Method</th>
                        <th>A Christmas Carol<br><span style="font-weight: 400;">(710 Paragraphs)</span></th>
                        <th>The Count of Monte Cristo<br><span style="font-weight: 400;">(14339 Paragraphs)</span></th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td style="text-align: left;">Semantic Chunking</td>
                        <td>212 seconds</td>
                        <td>4978 seconds</td>
                      </tr>
                      <tr>
                        <td style="text-align: left;">Recursive Chunking</td>
                        <td>0.1 seconds</td>
                        <td>0.6 seconds</td>
                      </tr>
                      <tr>
                        <td style="text-align: left;">HyDE</td>
                        <td>75 seconds</td>
                        <td>79 seconds</td>
                      </tr>
                      <tr>
                        <td style="text-align: left;">Proposition-Level</td>
                        <td>633 seconds</td>
                        <td>10302 seconds</td>
                      </tr>
                      <tr style="background-color: #f0f8ff;">
                        <td style="text-align: left;">LumberChunker</td>
                        <td><strong>95 seconds</strong></td>
                        <td><strong>1628 seconds</strong></td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="column">
                <!-- Table 12: Segmentation cost (per book) -->

                <!-- Accessible HTML table fallback for Table 12 -->
                <div class="table-card" aria-labelledby="table12-caption">
                  <table class="table is-bordered is-hoverable">
                    <caption id="table12-caption">Table 12: Cost comparison of segmenting two books with significantly different lengths.</caption>
                    <thead>
                      <tr>
                        <th></th>
                        <th>A Christmas Carol</th>
                        <th>The Count of Monte Cristo</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <th style="text-align: left;">Length</th>
                        <td>28k words</td>
                        <td>450k words</td>
                      </tr>
                      <tr>
                        <th style="text-align: left;">#LumberChunker Chunks</th>
                        <td>92</td>
                        <td>1476</td>
                      </tr>
                      <tr>
                        <th style="text-align: left;">Cost</th>
                        <td>$0.03</td>
                        <td>$0.40</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>


          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Conclusion Section -->
  <section class="section" style="margin-top: -2rem;">
    <div class="container is-max-desktop">
      <div class="columns is-centered has-text-left">
        <div class="column is-four-fifths">
          <h2 class="title is-3">Conclusion</h2>
          <div class="content has-text-justified">
            <p>
              LumberChunker shows that <strong>LLM-guided narrative segmentation</strong> can strike a rare balance of preserving story flow without demanding massive compute or retraining. 
              By letting an LLM detect <em>where meaning actually shifts</em> inside rolling paragraph windows, we obtain chunks that feel natural to humans and perform better for machines.
            </p>

            <p>
              On the <strong>GutenQA benchmark</strong>, LumberChunker consistently improves retrieval and downstream QA over traditional fixed-size and recursive methods,
              approaching the quality of manual, human-curated segmentations. Its efficiency, roughly linear in paragraph count, makes it practical for large-scale preprocessing in RAG pipelines.
            </p>

            <p style="margin-top: 1.5rem;">
              As RAG systems continue to scale, <strong>effective document segmentation</strong> will remain a key frontier.
              LumberChunker offers a practical step forward—one that respects both meaning and efficiency, making
              long-form understanding more accessible to modern language models.
            </p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Citation Section -->
  <section class="section" style="background-color: #f8f9fa; margin-top: 2rem; padding: 2rem 0;">
    <div class="container is-max-desktop">
      <div class="columns is-centered">
        <div class="column is-four-fifths">
          <h2 class="title is-3">Citation</h2>
          <div class="content">
            <p>If you find LumberChunker useful in your research, please consider citing:</p>
            <div style="position: relative;">
              <button id="copy-citation-btn" style="position: absolute; top: 10px; right: 10px; padding: 8px 16px; background-color: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background-color 0.3s; z-index: 10; display: flex; align-items: center; gap: 6px;" onmouseover="this.style.backgroundColor='#1976D2'" onmouseout="this.style.backgroundColor='#2196F3'">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                <span id="copy-btn-text">Copy</span>
              </button>
              <pre id="citation-text" style="background-color: #ffffff; padding: 1rem; padding-top: 2.5rem; border-radius: 5px; overflow-x: auto;"><code>@inproceedings{duarte-etal-2024-lumberchunker,
    title = "{L}umber{C}hunker: Long-Form Narrative Document Segmentation",
    author = "Duarte, Andr{\'e} V.  and
      Marques, Jo{\~a}o DS  and
      Gra{\c{c}}a, Miguel  and
      Freire, Miguel  and
      Li, Lei  and
      Oliveira, Arlindo L.",
    editor = "Al-Onaizan, Yaser  and
      Bansal, Mohit  and
      Chen, Yun-Nung",
    booktitle = "Findings of the Association for Computational Linguistics: EMNLP 2024",
    month = nov,
    year = "2024",
    address = "Miami, Florida, USA",
    publisher = "Association for Computational Linguistics",
    url = "https://aclanthology.org/2024.findings-emnlp.377/",
    doi = "10.18653/v1/2024.findings-emnlp.377",
    pages = "6473--6486",
    abstract = "Modern NLP tasks increasingly rely on dense retrieval methods to access up-to-date and relevant contextual information. We are motivated by the premise that retrieval benefits from segments that can vary in size such that a content{'}s semantic independence is better captured. We propose LumberChunker, a method leveraging an LLM to dynamically segment documents, which iteratively prompts the LLM to identify the point within a group of sequential passages where the content begins to shift. To evaluate our method, we introduce GutenQA, a benchmark with 3000 ``needle in a haystack'' type of question-answer pairs derived from 100 public domain narrative books available on Project Gutenberg. Our experiments show that LumberChunker not only outperforms the most competitive baseline by 7.37{\%} in retrieval performance (DCG@20) but also that, when integrated into a RAG pipeline, LumberChunker proves to be more effective than other chunking methods and competitive baselines, such as the Gemini 1.5M Pro."
}</code></pre>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>


  <footer class="footer" style="padding: 2rem 0; background-color: #f8f9fa;">
    <div class="container">
      <div class="content has-text-centered">
        <p>
          This website is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
        </p>
        <p>
          Website template adapted from <a href="https://github.com/nerfies/nerfies.github.io">Nerfies</a>.
        </p>
      </div>
    </div>
  </footer>

  <script>
    // D3.js Image and Chart Rendering
    
    // Function to render pipeline image using d3.js
    function renderPipelineImage() {
      const container = d3.select('#pipeline-image-wrapper');
      container.selectAll('*').remove();
      
      const svg = container.append('svg')
        .attr('width', '100%')
        .attr('height', 'auto')
        .style('max-width', '80%')
        .style('border-radius', '8px')
        .style('display', 'block')
        .style('margin', '0 auto');
      
      const img = new Image();
      img.onload = function() {
        const imgWidth = this.width;
        const imgHeight = this.height;
        
        svg.attr('viewBox', `0 0 ${imgWidth} ${imgHeight}`)
           .attr('preserveAspectRatio', 'xMidYMid meet');
        
        // Add the image
        svg.append('image')
          .attr('href', 'LumberChunker_pipeline.png')
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', imgWidth)
          .attr('height', imgHeight);
        
        // Define clickable areas for each pipeline step
        // Precisely matched to the vertical dividers in the pipeline image
        const clickableAreas = [
          {
            // Step 1: Document i Paragraph Extraction (leftmost section)
            x: imgWidth * 0.01,
            y: 0,
            width: imgWidth * 0.20, // First vertical line divider
            height: imgHeight,
            targetId: 'step1-extraction',
            section: 'Document i Paragraph Extraction'
          },
          {
            // Step 2: IDs Grouping (Gi) for LLM (second section)
            x: imgWidth * 0.21,
            y: 0,
            width: imgWidth * 0.30, // Largest section with the grouping boxes
            height: imgHeight,
            targetId: 'step2-grouping',
            section: 'IDs Grouping (Gi) for LLM'
          },
          {
            // Step 3: Gemini Query (third section with Google logo)
            x: imgWidth * 0.54,
            y: 0,
            width: imgWidth * 0.24, // Section with Gemini Query text
            height: imgHeight,
            targetId: 'step3-query',
            section: 'Gemini Query'
          },
          {
            // Step 4: Answer Extraction (rightmost section)
            x: imgWidth * 0.79,
            y: 0,
            width: imgWidth * 0.19, // Final section with answer IDs
            height: imgHeight,
            targetId: 'step3-query', // Links to step 3 section as step 4 is within the same example box
            section: 'Answer Extraction'
          }
        ];
        
        // Add clickable rectangles with hover effects
        clickableAreas.forEach((area, index) => {
          const group = svg.append('g')
            .style('cursor', 'pointer');
          
          // Invisible clickable rectangle
          const rect = group.append('rect')
            .attr('x', area.x)
            .attr('y', area.y)
            .attr('width', area.width)
            .attr('height', area.height)
            .attr('fill', 'transparent')
            .attr('stroke', 'none')
            .on('click', function() {
              // Smooth scroll to the corresponding section header
              const targetElement = document.querySelector(`#${area.targetId}`);
              if (targetElement) {
                const elementTop = targetElement.getBoundingClientRect().top + window.pageYOffset;
                window.scrollTo({
                  top: elementTop - 120, // Offset for fixed header
                  behavior: 'smooth'
                });
              }
            })
            .on('mouseover', function() {
              // Add highlight overlay on hover
              d3.select(this)
                .attr('fill', '#ffa726')
                .attr('fill-opacity', 0.15)
                .attr('stroke', '#ff9800')
                .attr('stroke-width', 4)
                .attr('stroke-dasharray', '8,4');
              
              // Show tooltip with section name
              const tooltipGroup = svg.append('g')
                .attr('class', `tooltip-${index}`)
                .style('pointer-events', 'none');
              
              // Calculate responsive font size based on image dimensions (much larger)
              const fontSize = Math.max(60, Math.min(40, imgWidth * 0.03));
              const centerX = area.x + area.width / 2;
              const centerY = imgHeight / 2;
              
              // Add text first to get its dimensions
              const tooltipText = tooltipGroup.append('text')
                .attr('x', centerX)
                .attr('y', centerY)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .style('font-size', `${fontSize}px`)
                .style('font-weight', '600')
                .style('fill', '#ff6f00')
                .style('font-family', "'Roboto', sans-serif")
                .text('Go To Section');
              
              // Get text bounding box for background
              const bbox = tooltipText.node().getBBox();
              const padding = 8;
              
              // Add background rectangle behind text (insert before text)
              const tooltipBg = tooltipGroup.insert('rect', 'text')
                .attr('x', bbox.x - padding)
                .attr('y', bbox.y - padding)
                .attr('width', bbox.width + padding * 2)
                .attr('height', bbox.height + padding * 2)
                .attr('rx', 6)
                .attr('ry', 6)
                .attr('fill', 'rgba(255, 255, 255, 0.95)')
                .attr('stroke', '#ffa726')
                .attr('stroke-width', 2)
                .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))');
            })
            .on('mouseout', function() {
              // Remove highlight
              d3.select(this)
                .attr('fill', 'transparent')
                .attr('fill-opacity', 0)
                .attr('stroke', 'none');
              
              // Remove tooltip
              svg.selectAll(`.tooltip-${index}`).remove();
            });
        });
      };
      img.src = 'LumberChunker_pipeline.png';
    }

    // Function to interpolate DCG values for any theta
    function interpolateDCGData(theta) {
      // Known data points
      const knownThetas = [450, 550, 650, 1000];
      const knownData = {
        450: [
          { k: 1, dcg: 0.47 },
          { k: 2, dcg: 0.533 },
          { k: 5, dcg: 0.576 },
          { k: 10, dcg: 0.595 },
          { k: 20, dcg: 0.606 }
        ],
        550: [
          { k: 1, dcg: 0.483 },
          { k: 2, dcg: 0.549 },
          { k: 5, dcg: 0.594 },
          { k: 10, dcg: 0.610 },
          { k: 20, dcg: 0.621 }
        ],
        650: [
          { k: 1, dcg: 0.447 },
          { k: 2, dcg: 0.518 },
          { k: 5, dcg: 0.565 },
          { k: 10, dcg: 0.583 },
          { k: 20, dcg: 0.596 }
        ],
        1000: [
          { k: 1, dcg: 0.420 },
          { k: 2, dcg: 0.487 },
          { k: 5, dcg: 0.538 },
          { k: 10, dcg: 0.562 },
          { k: 20, dcg: 0.573 }
        ]
      };

      // If theta is exactly a known value, return it directly
      if (knownData[theta]) {
        return knownData[theta];
      }

      // Find bracketing theta values
      let lowerTheta = knownThetas[0];
      let upperTheta = knownThetas[knownThetas.length - 1];
      
      for (let i = 0; i < knownThetas.length - 1; i++) {
        if (theta >= knownThetas[i] && theta <= knownThetas[i + 1]) {
          lowerTheta = knownThetas[i];
          upperTheta = knownThetas[i + 1];
          break;
        }
      }

      // Linear interpolation
      const t = (theta - lowerTheta) / (upperTheta - lowerTheta);
      const lowerData = knownData[lowerTheta];
      const upperData = knownData[upperTheta];

      return lowerData.map((point, i) => ({
        k: point.k,
        dcg: point.dcg + t * (upperData[i].dcg - point.dcg)
      }));
    }

    // Function to render DCG line chart showing different theta values
    function renderDCGChart() {
      const container = d3.select('#dcg-image-wrapper');
      container.selectAll('*').remove();
      
      // Get initial theta value from slider
      const slider = document.getElementById('theta-slider');
      const thetaValueDisplay = document.getElementById('theta-value');
      let currentTheta = parseInt(slider.value);
      
      // Dimensions
      const margin = { top: 50, right: 40, bottom: 60, left: 70 };
      const width = 900 - margin.left - margin.right;
      const height = 500 - margin.top - margin.bottom;
      
      // Create SVG
      const svg = container.append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .attr('preserveAspectRatio', 'xMidYMid meet')
        .style('max-width', '80%')
        .style('display', 'block')
        .style('margin', '0 auto')
        .style('background-color', 'white')
        .style('border-radius', '8px')
        .style('box-shadow', '0 2px 8px rgba(0,0,0,0.1)');
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      // Scales
      const x = d3.scaleLinear()
        .domain([1, 20])
        .range([0, width]);
      
      const y = d3.scaleLinear()
        .domain([0.40, 0.65])
        .range([height, 0]);
      
      // Grid lines
      g.append('g')
        .attr('class', 'grid')
        .attr('opacity', 0.2)
        .selectAll('line.horizontal')
        .data(y.ticks(6))
        .join('line')
        .attr('class', 'horizontal')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', d => y(d))
        .attr('y2', d => y(d))
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1);
      
      g.append('g')
        .attr('class', 'grid')
        .attr('opacity', 0.2)
        .selectAll('line.vertical')
        .data([1, 2, 5, 10, 20])
        .join('line')
        .attr('class', 'vertical')
        .attr('x1', d => x(d))
        .attr('x2', d => x(d))
        .attr('y1', 0)
        .attr('y2', height)
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1);
      
      // Axes with black borders
      const xAxis = g.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickValues([1, 2, 5, 10, 20]).tickFormat(d => d))
        .style('font-size', '14px');
      
      xAxis.selectAll('text')
        .style('fill', '#000')
        .style('font-weight', '500');
      
      xAxis.select('.domain')
        .attr('stroke', '#000')
        .attr('stroke-width', 2);
      
      const yAxis = g.append('g')
        .call(d3.axisLeft(y).ticks(6).tickFormat(d => d.toFixed(2)))
        .style('font-size', '14px');
      
      yAxis.selectAll('text')
        .style('fill', '#000')
        .style('font-weight', '500');
      
      yAxis.select('.domain')
        .attr('stroke', '#000')
        .attr('stroke-width', 2);
      
      // Add border frame
      g.append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'none')
        .attr('stroke', '#000')
        .attr('stroke-width', 2);
      
      // Axis labels
      svg.append('text')
        .attr('x', (width + margin.left + margin.right) / 2)
        .attr('y', height + margin.top + 45)
        .attr('text-anchor', 'middle')
        .style('font-size', '18px')
        .style('font-weight', '600')
        .style('fill', '#000')
        .text('k');
      
      svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -(height + margin.top + margin.bottom) / 2 + 30)
        .attr('y', 20)
        .attr('text-anchor', 'middle')
        .style('font-size', '18px')
        .style('font-weight', '600')
        .style('fill', '#000')
        .text('DCG');
      
      // Line generator
      const line = d3.line()
        .x(d => x(d.k))
        .y(d => y(d.dcg))
        .curve(d3.curveMonotoneX);
      
      // All reference theta values to show as transparent lines
      const referenceThetaValues = [
        { theta: 450, color: '#1e88e5', dashArray: '4,2' },
        { theta: 550, color: '#ffa726', dashArray: '8,4' },
        { theta: 650, color: '#26a69a', dashArray: '6,3' },
        { theta: 1000, color: '#ff7043', dashArray: '2,3' }
      ];
      
      // Create a group for all reference lines
      const referenceLinesGroup = g.append('g').attr('class', 'reference-lines-group');
      
      // Draw all reference lines as transparent
      referenceThetaValues.forEach((refConfig, index) => {
        const refData = interpolateDCGData(refConfig.theta);
        
        // Reference line
        const refLine = referenceLinesGroup.append('path')
          .datum(refData)
          .attr('class', `reference-line-${refConfig.theta}`)
          .attr('fill', 'none')
          .attr('stroke', refConfig.color)
          .attr('stroke-width', 2)
          .attr('stroke-dasharray', refConfig.dashArray)
          .attr('opacity', 0.2)
          .attr('d', line);
        
        // Reference markers
        referenceLinesGroup.selectAll(`.reference-marker-${refConfig.theta}`)
          .data(refData)
          .join('circle')
          .attr('class', `reference-marker-${refConfig.theta}`)
          .attr('cx', d => x(d.k))
          .attr('cy', d => y(d.dcg))
          .attr('r', 3)
          .attr('fill', 'white')
          .attr('stroke', refConfig.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', 0.2);
      });
      
      // Active line (changes with slider)
      const activeLine = g.append('path')
        .attr('class', 'active-line')
        .attr('fill', 'none')
        .attr('stroke', '#2196F3')
        .attr('stroke-width', 3)
        .attr('d', line(interpolateDCGData(currentTheta)));
      
      // Active markers
      const activeMarkersGroup = g.append('g').attr('class', 'active-markers-group');
      
      function updateActiveMarkers(theta) {
        const data = interpolateDCGData(theta);
        
        const markers = activeMarkersGroup.selectAll('.active-marker')
          .data(data);
        
        // Exit
        markers.exit().remove();
        
        // Enter + Update
        const markersEnter = markers.enter()
          .append('circle')
          .attr('class', 'active-marker')
          .attr('r', 5)
          .attr('fill', 'white')
          .attr('stroke', '#2196F3')
          .attr('stroke-width', 2.5)
          .style('cursor', 'pointer');
        
        markers.merge(markersEnter)
          .transition()
          .duration(300)
          .attr('cx', d => x(d.k))
          .attr('cy', d => y(d.dcg));
        
        // Hover effects
        activeMarkersGroup.selectAll('.active-marker')
          .on('mouseover', function(event, d) {
            d3.select(this)
              .transition()
              .duration(150)
              .attr('r', 7);
            
            // Show tooltip
            const tooltip = g.append('text')
              .attr('class', 'dcg-tooltip')
              .attr('x', x(d.k))
              .attr('y', y(d.dcg) - 15)
              .attr('text-anchor', 'middle')
              .style('font-size', '13px')
              .style('font-weight', '700')
              .style('fill', '#2196F3')
              .text(`θ=${theta}: ${d.dcg.toFixed(3)}`);
          })
          .on('mouseout', function() {
            d3.select(this)
              .transition()
              .duration(150)
              .attr('r', 5);
            
            g.selectAll('.dcg-tooltip').remove();
          });
      }
      
      // Initial markers
      updateActiveMarkers(currentTheta);
      
      // Add legend
      const legendGroup = g.append('g')
        .attr('transform', `translate(${width - 200}, 20)`);
      
      legendGroup.append('rect')
        .attr('x', -10)
        .attr('y', -10)
        .attr('width', 185)
        .attr('height', 155)
        .attr('fill', 'white')
        .attr('stroke', '#000')
        .attr('stroke-width', 1.5)
        .attr('rx', 4);
      
      // Current theta legend item
      const currentLegend = legendGroup.append('g')
        .attr('transform', 'translate(0, 0)');
      
      currentLegend.append('line')
        .attr('x1', 0)
        .attr('x2', 30)
        .attr('y1', 0)
        .attr('y2', 0)
        .attr('stroke', '#2196F3')
        .attr('stroke-width', 3);
      
      currentLegend.append('circle')
        .attr('cx', 15)
        .attr('cy', 0)
        .attr('r', 5)
        .attr('fill', 'white')
        .attr('stroke', '#2196F3')
        .attr('stroke-width', 2.5);
      
      const currentLabel = currentLegend.append('text')
        .attr('x', 40)
        .attr('y', 0)
        .attr('dy', '0.32em')
        .style('font-size', '13px')
        .style('font-weight', '600')
        .style('fill', '#000')
        .text(`Current θ: ${currentTheta}`);
      
      // Reference theta legend items
      referenceThetaValues.forEach((refConfig, i) => {
        const refLegend = legendGroup.append('g')
          .attr('transform', `translate(0, ${(i + 1) * 28})`);
        
        refLegend.append('line')
          .attr('x1', 0)
          .attr('x2', 30)
          .attr('y1', 0)
          .attr('y2', 0)
          .attr('stroke', refConfig.color)
          .attr('stroke-width', 2)
          .attr('stroke-dasharray', refConfig.dashArray)
          .attr('opacity', 0.5);
        
        refLegend.append('circle')
          .attr('cx', 15)
          .attr('cy', 0)
          .attr('r', 3)
          .attr('fill', 'white')
          .attr('stroke', refConfig.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', 0.5);
        
        refLegend.append('text')
          .attr('x', 40)
          .attr('y', 0)
          .attr('dy', '0.32em')
          .style('font-size', '12px')
          .style('font-weight', '400')
          .style('fill', '#666')
          .text(`θ: ${refConfig.theta}`);
      });
      
      // Slider interaction
      slider.addEventListener('input', function() {
        const newTheta = parseInt(this.value);
        currentTheta = newTheta;
        thetaValueDisplay.textContent = newTheta;
        
        // Update the active line
        const newData = interpolateDCGData(newTheta);
        activeLine
          .transition()
          .duration(300)
          .attr('d', line(newData));
        
        // Update markers
        updateActiveMarkers(newTheta);
        
        // Update legend
        currentLabel.text(`Current θ: ${newTheta}`);
      });
      
      // Set up Intersection Observer for scroll-triggered animation
      const dcgWrapper = document.getElementById('dcg-image-wrapper');
      let hasAnimatedDCG = false;
      
      const dcgObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !hasAnimatedDCG) {
            hasAnimatedDCG = true;
            
            // Animate all reference lines
            referenceThetaValues.forEach((refConfig, index) => {
              const refLine = referenceLinesGroup.select(`.reference-line-${refConfig.theta}`);
              const refPath = refLine.node();
              const refLength = refPath.getTotalLength();
              
              refLine
                .attr('stroke-dasharray', `${refConfig.dashArray},${refLength}`)
                .attr('stroke-dashoffset', refLength)
                .transition()
                .duration(1500)
                .delay(index * 150)
                .ease(d3.easeQuadInOut)
                .attr('stroke-dashoffset', 0)
                .on('end', function() {
                  d3.select(this).attr('stroke-dasharray', refConfig.dashArray);
                });
              
              // Animate reference markers
              referenceLinesGroup.selectAll(`.reference-marker-${refConfig.theta}`)
                .attr('opacity', 0)
                .transition()
                .delay(1500 + index * 150)
                .duration(400)
                .attr('opacity', 0.2);
            });
            
            // Animate active line
            const activePath = activeLine.node();
            const activeLength = activePath.getTotalLength();
            
            activeLine
              .attr('stroke-dasharray', activeLength)
              .attr('stroke-dashoffset', activeLength)
              .transition()
              .duration(1800)
              .delay(800)
              .ease(d3.easeQuadInOut)
              .attr('stroke-dashoffset', 0)
              .on('end', function() {
                d3.select(this).attr('stroke-dasharray', 'none');
              });
            
            // Animate active markers
            activeMarkersGroup.selectAll('.active-marker')
              .attr('opacity', 0)
              .transition()
              .delay((d, i) => 2600 + i * 150)
              .duration(400)
              .attr('opacity', 1);
            
            // Animate legend
            legendGroup
              .attr('opacity', 0)
              .transition()
              .delay(3000)
              .duration(600)
              .attr('opacity', 1);
          }
        });
      }, {
        threshold: 0.3,
        rootMargin: '0px'
      });
      
      if (dcgWrapper) {
        dcgObserver.observe(dcgWrapper);
      }
    }

    // Function to render QA Accuracy bar chart
    function renderQAChart() {
      const container = d3.select('#qa-image-wrapper');
      container.selectAll('*').remove();
      
      // Data: QA Accuracy percentages - matching the reference image exactly
      const data = [
        { method: 'Closed-Book', accuracy: 26.43, color: '#7cb342', label: 'Closed-Book' },
        { method: 'Open-Book', accuracy: 37.76, color: '#29b6f6', label: 'Open-Book' },
        { method: 'RAG - Recursive Chunks', accuracy: 84.96, color: '#7986cb', label: 'RAG - Recursive Chunks' },
        { method: 'RAG - LumberChunker', accuracy: 88.89, color: '#ffb74d', label: 'RAG - LumberChunker' },
        { method: 'RAG - Manual Chunks', accuracy: 90.53, color: '#757575', label: 'RAG - Manual Chunks' }
      ];
      
      // Dimensions
      const margin = { top: 50, right: 40, bottom: 70, left: 80 };
      const width = 1000 - margin.left - margin.right;
      const height = 500 - margin.top - margin.bottom;
      
      // Create SVG
      const svg = container.append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .attr('preserveAspectRatio', 'xMidYMid meet')
        .style('max-width', '80%')
        .style('display', 'block')
        .style('margin', '0 auto')
        .style('background-color', 'white')
        .style('border-radius', '8px')
        .style('box-shadow', '0 2px 8px rgba(0,0,0,0.1)');
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      // Scales
      const x = d3.scaleBand()
        .domain(data.map((d, i) => i))
        .range([0, width])
        .padding(0.25);
      
      const y = d3.scaleLinear()
        .domain([0, 100])
        .range([height, 0]);
      
      // Grid lines
      g.append('g')
        .attr('class', 'grid')
        .attr('opacity', 0.2)
        .selectAll('line')
        .data(y.ticks(5))
        .join('line')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', d => y(d))
        .attr('y2', d => y(d))
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1);
      
      // Axes with black borders
      const xAxis = g.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickFormat(() => ''))
        .style('font-size', '14px');
      
      xAxis.select('.domain')
        .attr('stroke', '#000')
        .attr('stroke-width', 2);
      
      xAxis.selectAll('.tick')
        .remove();
      
      const yAxis = g.append('g')
        .call(d3.axisLeft(y).ticks(5).tickFormat(d => d))
        .style('font-size', '16px');
      
      yAxis.selectAll('text')
        .style('fill', '#000')
        .style('font-weight', '500');
      
      yAxis.select('.domain')
        .attr('stroke', '#000')
        .attr('stroke-width', 2);
      
      // Add border frame
      g.append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'none')
        .attr('stroke', '#000')
        .attr('stroke-width', 2);
      
      // Axis label
      svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -(height + margin.top + margin.bottom) / 2 + 30)
        .attr('y', 25)
        .attr('text-anchor', 'middle')
        .style('font-size', '18px')
        .style('font-weight', '600')
        .style('fill', '#000')
        .text('Accuracy (%)');
      
      // Draw bars (without animation initially)
      let isAnimating = false;
      
      const bars = g.selectAll('.bar')
        .data(data)
        .join('rect')
        .attr('class', 'bar')
        .attr('x', (d, i) => x(i))
        .attr('y', height)
        .attr('width', x.bandwidth())
        .attr('height', 0)
        .attr('fill', d => d.color)
        .attr('stroke', '#000')
        .attr('stroke-width', 1.5)
        .style('cursor', 'pointer')
        .on('mouseover', function(event, d) {
          // Only allow hover effect if not currently animating
          if (!isAnimating) {
            d3.select(this)
              .transition()
              .duration(200)
              .attr('opacity', 0.8);
          }
        })
        .on('mouseout', function() {
          // Only allow hover effect if not currently animating
          if (!isAnimating) {
            d3.select(this)
              .transition()
              .duration(200)
              .attr('opacity', 1);
          }
        });
      
      // Add value labels (hidden initially)
      const labels = g.selectAll('.label')
        .data(data)
        .join('text')
        .attr('class', 'label')
        .attr('x', (d, i) => x(i) + x.bandwidth() / 2)
        .attr('y', d => y(d.accuracy) - 10)
        .attr('text-anchor', 'middle')
        .style('font-size', '18px')
        .style('font-weight', '700')
        .style('fill', '#000')
        .attr('opacity', 0)
        .text(d => d.accuracy.toFixed(2));
      
      // Add method labels at bottom of each bar
      const bottomLabels = g.selectAll('.bottom-label')
        .data(data)
        .join('text')
        .attr('class', 'bottom-label')
        .attr('x', (d, i) => x(i) + x.bandwidth() / 2)
        .attr('y', height + 15)
        .attr('text-anchor', 'middle')
        .style('font-size', '13px')
        .style('font-weight', '500')
        .style('fill', '#000')
        .each(function(d, i) {
          const text = d3.select(this);
          const words = d.label.split(' - ');
          
          if (words.length > 1) {
            // Multi-line label for methods with " - "
            text.append('tspan')
              .attr('x', x(i) + x.bandwidth() / 2)
              .attr('dy', '0')
              .text(words[0]);
            text.append('tspan')
              .attr('x', x(i) + x.bandwidth() / 2)
              .attr('dy', '1.1em')
              .text(words[1]);
          } else {
            // Single line label
            text.text(d.label);
          }
        });
      
      // Add legend in top-left corner
      const legendGroup = g.append('g')
        .attr('transform', `translate(30, 30)`)
        .attr('opacity', 0);
      
      // Legend background
      legendGroup.append('rect')
        .attr('x', -12)
        .attr('y', -12)
        .attr('width', 200)
        .attr('height', 145)
        .attr('fill', 'white')
        .attr('stroke', '#000')
        .attr('stroke-width', 1.5)
        .attr('rx', 2);
      
      // Legend items
      data.forEach((d, i) => {
        const legendRow = legendGroup.append('g')
          .attr('transform', `translate(5, ${i * 26 + 5})`);
        
        // Color box
        legendRow.append('rect')
          .attr('x', 0)
          .attr('y', -9)
          .attr('width', 18)
          .attr('height', 18)
          .attr('fill', d.color)
          .attr('stroke', '#000')
          .attr('stroke-width', 1);
        
        // Label
        legendRow.append('text')
          .attr('x', 25)
          .attr('y', 0)
          .attr('dy', '0.32em')
          .style('font-size', '12.5px')
          .style('font-weight', '400')
          .style('fill', '#000')
          .text(d.label);
      });
      
      // Set up Intersection Observer for scroll-triggered animation
      const qaWrapper = document.getElementById('qa-image-wrapper');
      let hasAnimated = false;
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !hasAnimated) {
            hasAnimated = true;
            isAnimating = true;
            
            // Animate bars sliding up
            bars.transition()
              .delay((d, i) => i * 150)
              .duration(1000)
              .ease(d3.easeCubicOut)
              .attr('y', d => y(d.accuracy))
              .attr('height', d => height - y(d.accuracy))
              .on('end', function(d, i) {
                // Re-enable hover effects after the last bar finishes animating
                if (i === data.length - 1) {
                  isAnimating = false;
                }
              });
            
            // Animate labels fading in
            labels.transition()
              .delay((d, i) => i * 150 + 800)
              .duration(500)
              .attr('opacity', 1);
            
            // Animate legend appearance
            legendGroup.transition()
              .delay(1200)
              .duration(600)
              .attr('opacity', 1);
          }
        });
      }, {
        threshold: 0.3,
        rootMargin: '0px'
      });
      
      if (qaWrapper) {
        observer.observe(qaWrapper);
      }
    }

    // Render all visualizations when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      renderPipelineImage();
      renderDCGChart();
      renderQAChart();
      
      // Copy citation button functionality
      const copyBtn = document.getElementById('copy-citation-btn');
      const citationText = document.getElementById('citation-text');
      const btnText = document.getElementById('copy-btn-text');
      
      if (copyBtn && citationText) {
        copyBtn.addEventListener('click', function() {
          // Get the text content from the citation
          const textToCopy = citationText.textContent.trim();
          
          // Copy to clipboard
          navigator.clipboard.writeText(textToCopy).then(function() {
            // Success feedback
            btnText.textContent = 'Copied!';
            copyBtn.style.backgroundColor = '#4CAF50';
            
            // Reset after 2 seconds
            setTimeout(function() {
              btnText.textContent = 'Copy';
              copyBtn.style.backgroundColor = '#2196F3';
            }, 2000);
          }).catch(function(err) {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = textToCopy;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            
            try {
              document.execCommand('copy');
              btnText.textContent = 'Copied!';
              copyBtn.style.backgroundColor = '#4CAF50';
              
              setTimeout(function() {
                btnText.textContent = 'Copy';
                copyBtn.style.backgroundColor = '#2196F3';
              }, 2000);
            } catch (err) {
              console.error('Failed to copy text: ', err);
              btnText.textContent = 'Failed';
              setTimeout(function() {
                btnText.textContent = 'Copy';
              }, 2000);
            }
            
            document.body.removeChild(textArea);
          });
        });
      }
    });
  </script>

</body>
</html>